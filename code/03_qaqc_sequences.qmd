---
title: "Step 3: QAQC RNA sequences"
subtitle: "Use `FastQC`, `MultiQC`, and `Fastp` to clean up sequences"
author: "Sarah Tanja"
date: 10/10/2024
date-format: long
date-modified: today
format: gfm
toc: true
toc-depth: 3
link-external-icon: true
link-external-newwindow: true
---

```{r setup, include = FALSE}
# Set global chunk options
knitr::opts_chunk$set(eval = FALSE, echo = TRUE, message = FALSE, warning = FALSE)
```

# Goals

In this script, we will generate FastQC/MultiQC for raw sequences, conduct trimming and cleaning, then generate reports for cleaned sequences.

# Setup conda environment

Create and activate conda environment (must already have installed miniconda)

::: {.callout-caution appearance="minimal"}
Execute the following conda commands in the terminal so that you can respond to `Proceed([y]/n)?` with a `y`
:::

``` bash
conda create -n mcap2024
```

```{r, engine = 'bash'}
conda activate mcap2024
```

Install programs within conda environment

-   [fastqc](https://anaconda.org/bioconda/fastqc)

``` bash
conda install bioconda::fastqc
```

*FastQC generates sequence quality information of your reads*

-   [multiqc](https://anaconda.org/bioconda/multiqc), [git developer version](Installation)

``` bash
pip install --upgrade --force-reinstall git+https://github.com/MultiQC/MultiQC.git
```

*Multiqc summarizes FastQC analysis logs and summarizes results in an html report*

-   [fastp](https://anaconda.org/bioconda/fastp)

``` bash
conda install bioconda::fastp
```

*FastP provides fast all-in-one preprocessing for FastQ files*

conda install hisat2 conda install samtools

# Run `FastQC`on raw sequences

FastQC on Raven lives: `/home/shared/FastQC/fastqc`

```{bash}
/home/shared/FastQC/fastqc -h
```



Run FASTQC on untrimmedor 'raw'.fastq.gz files :
Below modified from Roberts Lab [Code Snippets](https://robertslab.github.io/resources/code_Snippets/)     
```{bash}
# Set CPU threads to use
threads=40

# Populate array with FastQ files
fastq_array=(~/sarahtanja/coral-embryo-leachate/*.fastq.gz)

# Pass array contents to new variable
fastqc_list=$(echo "${fastq_array[*]}")

# Run FastQC
# NOTE: Do NOT quote ${fastqc_list}
/home/shared/FastQC/fastqc \
--threads ${threads} \
--outdir /home/shared/8TB_HDD_02/graceac9/analyses/pycno/ \
${fastqc_list}
```


```{bash}
cd rawfastq/00_fastq
fastqc ./*.fastq.gz
```

Make a subdirectory for your FastQC results and move FastQC results there

```{bash}
cd ../output
mkdir 03_qaqc
mv ../../rawfastq/00_fastq/*fastqc* ./
```

# Compile the `MultiQC` report

```{bash}
cd ../output/03_qaqc
multiqc ./
```

# Interpretation of `MultiQC` report for raw reads

Watch a quick [6-min tutorial](https://www.youtube.com/watch?v=qPbIlO_KWN0) on how to navigate in the MultiQC Report

# Create a Bash variables file

This allows usage of Bash variables across R Markdown chunks.

## Data directories

```{r, engine = bash}
{
echo "#### Assign Variables ####"
echo ""

echo "# Data directories"
echo 'export project_dir=~/sarahtanja/coral-embryo-leachate'
echo 'export output_dir_top=${project_dir}/output/03_qaqc/cleaned_reads_fastqc'
echo 'export raw_reads_dir=${project_dir}/rawfastq/00_fastq'
#echo 'export raw_reads_url="https://owl.fish.washington.edu/nightingales/E5-coral-time-series/30-1047560508/"'
#echo 'export trimmed_fastqs_dir=${output_dir_top}/trimmed-fastqs'
#echo 'export trimmed_fastqc_dir=${output_dir_top}/trimmed-fastqc'
echo ""
} > .bashvars

cat .bashvars
```

```{r, engine = 'bash'}
{
echo "# Paths to programs"
echo 'export programs_dir="/home/shared"'
echo 'export fastp="${programs_dir}/fastp"'
echo 'export fastqc=${programs_dir}/FastQC-0.12.1/fastqc'
echo 'export multiqc=/home/sam/programs/mambaforge/bin/multiqc'
echo ""
} >> .bashvars

cat .bashvars
```

```{r, engine = 'bash'}
{
echo "# Set FastQ filename patterns"
echo "export fastq_pattern='*.fastq.gz'"
echo "export R1_fastq_pattern='*_R1_*.fastq.gz'"
echo "export R2_fastq_pattern='*_R2_*.fastq.gz'"
echo "export trimmed_fastq_pattern='*fastp-trim.fq.gz'"
echo ""
} >> .bashvars

cat .bashvars
```

```{r, engine = 'bash'}
{
echo "# Set number of CPUs to use"
echo 'export threads=40'
echo ""
} >> .bashvars

cat .bashvars
```

```{r, engine = 'bash'}
{
echo "## Inititalize arrays"
echo 'export fastq_array_R1=()'
echo 'export fastq_array_R2=()'
echo 'export raw_fastqs_array=()'
echo 'export R1_names_array=()'
echo 'export R2_names_array=()'
echo ""
} >> .bashvars

cat .bashvars
```

```{r, engine = 'bash'}
{
echo "# Programs associative array"
echo "declare -A programs_array"
echo "programs_array=("
echo '[fastp]="${fastp}" \'
echo '[fastqc]="${fastqc}" \'
echo '[multiqc]="${multiqc}" \'
echo ")"
echo ""

echo "# Print formatting"
echo 'export line="--------------------------------------------------------"'
echo ""
} >> .bashvars

cat .bashvars
```

# Clean reads with `fastp`

-   remove adapters
-   remove low-quality reads
-   remove reads with high number of unknown bases

In this script, we are trimming and cleaning with the following settings:

-   remove adapter sequences `--adapter_sequence=AGATCGGAAGAGCACACGTCTGAACTCCAGTCA`
-   enable polyX trimming on 3' end at length of 6 `--trim_poly_x 6`
-   filter by minimum phred quality score of \>30 `-q 30`
-   enable low complexity filter `-y`
-   set complexity filter threshold of 50% required `-Y 50`

`fastp` all [options](https://github.com/OpenGene/fastp?tab=readme-ov-file#:~:text=of%201%20~%206.-,all%20options,-usage%3A%20fastp%20%2Di) can be found in the git README.

-   \--in1 - Path to forward read input

-   \--in2 - Path to reverse read input

-   \--out1 - Path to forward read output

-   \--out2 - Path to reservse read output

-   \--failed_out - Specify file to store reads that fail filters

-   `-q, --qualified_quality_phred` \| The quality value that a base is qualified. Default 15 means phred quality \>=Q15 is qualified. \|

    -   Chosen value is 30

-   `-x, --trim_poly_x` \| Enable polyX trimming in 3' ends

-   `--poly_x_min_len 6` \|

-   `--detect_adapter_for_pe` \| Adapters can be trimmed by overlap analysis, however, \--detect_adapter_for_pe will usually result in slightly cleaner output than overlap detection alone. This results in a slightly slower run time

-   `--html` \| The html format report file name

How to do a [for loop in bash](https://stackoverflow.com/questions/9612090/how-to-loop-through-file-names-returned-by-find)

```{bash}
# Load bash variables into memory
source .bashvars

# Make output directories, if it doesn't exist
#mkdir --parents "${trimmed_fastqs_dir}"

# Change to raw reads directory
cd "${raw_reads_dir}"

# Create arrays of fastq R1 files and sample names
for fastq in ${R1_fastq_pattern}
do
  fastq_array_R1+=("${fastq}")
  R1_names_array+=("$(echo "${fastq}" | awk -F"_" '{print $1}')")
done

# Create array of fastq R2 files
for fastq in ${R2_fastq_pattern}
do
  fastq_array_R2+=("${fastq}")
  R2_names_array+=("$(echo "${fastq}" | awk -F"_" '{print $1}')")
done

# Create list of fastq files used in analysis
# Create MD5 checksum for reference
#if [ ! -f "${output_dir_top}"/raw-fastq-checksums.md5 ]; then
#for fastq in *.gz
#  do
#    md5sum ${fastq} >> "${output_dir_top}"/raw-fastq-checksums.md5
#  done
#fi

# Run fastp on files
# Adds JSON report output for downstream usage by MultiQC
for index in "${!fastq_array_R1[@]}"
do
  R1_sample_name=$(echo "${R1_names_array[index]}")
  R2_sample_name=$(echo "${R2_names_array[index]}")
  ${fastp} \
  --in1 ${fastq_array_R1[index]} \
  --in2 ${fastq_array_R2[index]} \
  --detect_adapter_for_pe \
  --qualified_quality_phred 30 \ 
  --thread 40 \
  --html "${output_dir_top}"/"${R1_sample_name}".fastp-trim.report.html \
  --json "${output_dir_top}"/"${R1_sample_name}".fastp-trim.report.json \
  --out1 "${output_dir_top}"/"${R1_sample_name}"_R1_001.fastp-trim.fq.gz \
  --out2 "${output_dir_top}"/"${R2_sample_name}"_R2_001.fastp-trim.fq.gz \
  2>> "${output_dir_top}"/fastp.stderr

  # Generate md5 checksums for newly trimmed files
  cd "${output_dir_top}"
  md5sum "${R1_sample_name}"_R1_001.fastp-trim.fq.gz > "${R1_sample_name}"_R1_001.fastp-trim.fq.gz.md5
  md5sum "${R2_sample_name}"_R2_001.fastp-trim.fq.gz > "${R2_sample_name}"_R2_001.fastp-trim.fq.gz.md5
  cd -
done
```

```{r, engine='bash'}

conda activate mcap2024

fastp
--in1 ../rawfastq/00_fastq/6C14_R1_001.fastq.gz \
--in2 ../rawfastq/00_fastq/6C14_R2_001.fastq.gz \
--out1 ../data/cleaned_reads/6C14_R1_001.clean.fastq.gz \
--out2 ../data/cleaned_reads/6C14_R2_001.clean.fastq.gz \
--failed_out ../cleaned_reads/6C14_failed.txt \
--detect_adapter_for_pe \
--qualified_quality_phred 30 \ 
--trim_poly_x 6 \
--thread 40

```

# Run cleaned reads through FastQC

# Compile cleaned reads MultiQC report

# Summary

Clean sequences are now ready for alignment.
